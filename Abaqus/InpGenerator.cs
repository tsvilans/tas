using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

using Rhino.Geometry;
using tas.Core;

namespace tas.Abaqus
{
    public class InpGenerator
    {
        public List<Assembly> Assemblies;
        public List<Part> Parts;
        public List<Material> Materials;
        public List<BoundaryCondition> BoundaryConditions;
        public List<Load> Loads;
        public List<Step> Steps;

        public string JobName, Author;

        public InpGenerator()
        {
            Assemblies = new List<Assembly>();
            Parts = new List<Part>();
            Materials = new List<Material>();
            BoundaryConditions = new List<BoundaryCondition>();
            Loads = new List<Load>();
            Steps = new List<Step>();
            JobName = "Job-99";
        }

        public void WriteHeader(List<string> inp)
        {
            inp.Add("*Heading");
            inp.Add($"**Job name: {JobName}");
            inp.Add($"**Generated by: {Author}");
            inp.Add($"*Preprint, echo=NO, model=NO, history=NO, contact=NO");
        }

        public void WriteParts(List<string> inp)
        {
            inp.Add("**");
            inp.Add("** PARTS");
            inp.Add("**");

            foreach (Part prt in Parts)
            {
                WritePart(inp, prt);
            }
        }

        public void WritePart(List<string> inp, Part prt)
        {
            inp.Add($"*Part, name={prt.Name}");

            inp.Add("*Node");

            foreach (Node n in prt.Nodes)
            {
                inp.Add($"    {n.Id}, {n.X}, {n.Y}, {n.Z}");
            }

            if (prt.Elements.Count < 1) throw new Exception("Part must contain elements!");

            inp.Add($"*Element, type={prt.Elements[0].Type}");
            string line = "";
            foreach (Element ele in prt.Elements)
            {
                line = $"    {ele.Id}";
                foreach(int ni in ele.Data)
                {
                    line += $", {ni}";
                }
                inp.Add(line);
            }

            inp.Add("*Nset, nset=AllNodes, generate");
            inp.Add($"1, {prt.Nodes.Count}, 1");

            inp.Add("*Elset, elset=AllElements, generate");
            inp.Add($"1, {prt.Elements.Count}, 1");

            inp.Add("*Distribution, name=OrientationDistribution, location=ELEMENT, Table=OrientationDistributionTable");
            inp.Add(", 1., 0., 0., 0., 1., 0.");

            foreach (ElementOrientation ori in prt.ElementOrientations)
            {
                inp.Add($"    {ori.Id}, {ori.Data.ZAxis.X}, {ori.Data.ZAxis.Y}, {ori.Data.ZAxis.Z}, {ori.Data.YAxis.X}, {ori.Data.YAxis.Y}, {ori.Data.YAxis.Z}, ");
            }

            inp.Add("*Orientation, name=Orientation-1, system=RECTANGULAR");
            inp.Add("OrientationDistribution");
            inp.Add("1, 0");


            inp.Add("** Section: Glulam section");
            inp.Add($"*Solid Section, elset=AllElements, orientation=Orientation-1, material={prt.Material.Name}");
            inp.Add(",");

            inp.Add("*End Part");
        }

        public void WriteAssemblies(List<string> inp)
        {
            inp.Add("**");
            inp.Add("** ASSEMBLIES");
            inp.Add("**");

            foreach (Assembly ass in Assemblies)
            {
                WriteAssembly(inp, ass);
            }
        }

        public void WriteAssembly(List<string> inp, Assembly ass)
        {
            inp.Add($"*Assembly, name={ass.Name}");
            inp.Add("**");

            foreach (PartInstance prt in ass.Instances)
            {
                inp.Add($"*Instance, name={prt.Name}, part={prt.Part.Name}");
                inp.Add("*End Instance");
                inp.Add("**");
            }

            string line = "";

            foreach (ElementSet set in ass.ElementSets)
            {
                if (set.Data.Count < 1) continue;

                line = $"*Elset, elset={set.Name}";
                if (set.Instance != null)
                    line += $", instance={set.Instance.Name}";
                inp.Add(line);

                line = set.Data[0].ToString() + ", ";
                for (int i = 1; i < set.Data.Count; ++i)
                {
                    if (i.Modulus(16) < 1)
                    {
                        inp.Add(line);
                        line = "";
                    }

                    line += set.Data[i].ToString() + ", ";
                }
                //line = string.Join<int>(",", set.Data);

                inp.Add(line);
            }

            foreach (NodeSet set in ass.NodeSets)
            {
                if (set.Data.Count < 1) continue;

                line = $"*Nset, nset={set.Name}";
                if (set.Instance != null)
                    line += $", instance={set.Instance.Name}";
                inp.Add(line);

                line = set.Data[0].ToString() + ", ";
                for (int i = 1; i < set.Data.Count; ++i)
                {
                    if (i.Modulus(16) < 1)
                    {
                        inp.Add(line);
                        line = "";
                    }

                    line += set.Data[i].ToString() + ", ";
                }
                //line = string.Join<int>(",", set.Data);

                inp.Add(line);
            }

            foreach (Surface srf in ass.Surfaces)
            {
                inp.Add($"*Surface, type={srf.Type}, name={srf.Name}");
                int N = Math.Min(srf.Sets.Count, srf.ElementSides.Count);

                for (int i = 0; i < N; ++i)
                {
                    inp.Add($"{srf.Sets[i].Name}, {srf.ElementSides[i]}");
                }
            }

            inp.Add("*End Assembly");

        }

        public void WriteMaterials(List<string> inp)
        {
            inp.Add("**");
            inp.Add("** MATERIALS");
            inp.Add("**");

            foreach(Material mat in Materials)
            {
                WriteMaterial(inp, mat);
            }

            inp.Add("**----------------");

        }

        public void WriteMaterial(List<string> inp, Material mat)
        {
            inp.Add($"*Material, name={mat.Name}");

            inp.Add("*Density");
            inp.Add($"{mat.Density}");

            inp.Add("*Elastic, type=ENGINEERING CONSTANTS ");
            inp.Add($"{mat.EngineeringConstants[0]}, {mat.EngineeringConstants[1]}, {mat.EngineeringConstants[2]}, " +
                $"{mat.EngineeringConstants[3]}, {mat.EngineeringConstants[4]}, {mat.EngineeringConstants[5]}, " +
                $"{mat.EngineeringConstants[6]}, {mat.EngineeringConstants[7]}, ");
            inp.Add($"{mat.EngineeringConstants[8]}");
        }

        public void WriteSteps(List<string> inp)
        {
            foreach (Step step in Steps)
            {
                WriteStep(inp, step);
            }

            inp.Add("**----------------");
        }

        protected void WriteStep(List<string> inp, Step step)
        {
            inp.Add("**");
            inp.Add($"** STEP: {step.Name}");
            inp.Add("**");

            string is_nlgeom = step.nlgeom ? "YES" : "NO";
            inp.Add($"*Step, name={step.Name}, nlgeom={is_nlgeom}");
            string is_static = step.Static ? "Static" : "Dynamic";
            inp.Add($"*{is_static}");
            inp.Add("1., 1., 1e-05, 1.");

            inp.Add("**");
            inp.Add("** BOUNDARY CONDITIONS");
            inp.Add("**");

            foreach (BoundaryCondition bc in step.BoundaryConditions)
            {
                WriteBoundaryCondition(inp, bc);
            }

            inp.Add("**");
            inp.Add("** LOADS");
            inp.Add("**");

            foreach (Load lo in step.Loads)
            {
                WriteLoad(inp, lo);
            }

            inp.Add("**");
            inp.Add("** OUTPUT REQUESTS");
            inp.Add("**");

            inp.Add("*Restart, write, frequency=0");

            inp.Add("**");
            inp.Add("** FIELD OUTPUT: F-Output-1");
            inp.Add("**");

            inp.Add("*Output, field, variable=PRESELECT");

            inp.Add("**");
            inp.Add("** HISTORY OUTPUT: H-Output-1");
            inp.Add("**");

            inp.Add("*Output, history, variable=PRESELECT");

            inp.Add("*End Step");
        }

        /*
        protected void WriteBoundaryConditions(List<string> inp)
        {
            inp.Add("**");
            inp.Add("** BOUNDARY CONDITIONS");
            inp.Add("**");

            foreach (BoundaryCondition bc in BoundaryConditions)
            {
                WriteBoundaryCondition(inp, bc);
            }
        }
        */

        protected void WriteBoundaryCondition(List<string> inp, BoundaryCondition bc)
        {
            inp.Add($"** Name: {bc.Name} Type: {bc.Type}");
            inp.Add("*Boundary");

            switch(bc.Type)
            {
                case (BoundaryCondition.BoundaryConditionType.CUSTOM):
                    throw new NotImplementedException("CUSTOM boundary condition not implemented yet.");
                    inp.Add($"{bc.Set.Name}");
                    break;
                default:
                    if (bc.Set != null)
                        inp.Add($"{bc.Set.Name}, {bc.Type.ToString()}");
                    break;
            }




            //inp.Add("Set-1, 1, 1");
            //inp.Add("Set-1, 2, 2");
            //inp.Add("Set-1, 3, 3");
        }

        protected void WriteLoads(List<string> inp)
        {
            inp.Add("**");
            inp.Add("** LOADS");
            inp.Add("**");

            foreach (Load lo in Loads)
            {
                WriteLoad(inp, lo);
            }
        }

        protected void WriteLoad(List<string> inp, Load lo)
        {
            inp.Add($"** Name: {lo.Name} Type: {lo.Type}");
            inp.Add("*Dload");
            inp.Add(", GRAV, 9.8, 0., 0., -1.");
        }

        public List<string> Generate()
        {
            List<string> inp = new List<string>();

            WriteHeader(inp);

            inp.Add("*Distribution Table, name=OrientationDistributionTable"); // This should be a DistributionTable object
            inp.Add("coord3D, coord3D");

            // Write all parts
            WriteParts(inp);

            // Write all assemblies
            WriteAssemblies(inp);

            // Write all materials
            WriteMaterials(inp);

            // Write all steps with associated boundary conditions and loads
            WriteSteps(inp);

            return inp;
        }
    }
}
